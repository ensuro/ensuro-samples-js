#!/usr/bin/env node

const { ethers } = require('ethers');
const fs = require('fs');

const RM_ADDRESS = process.env.RM_ADDRESS;

const yargs = require('yargs');
const ensuro = require('./ensuro.js');
const envsigner = require('./envsigner.js');
const signer = envsigner.getSigner(process.env);

async function newPolicyCommand(argv) {
  const rm = new ethers.Contract(argv.rmAddress, ensuro.ABIS[argv.rmType], signer);
  const policyData = JSON.parse(fs.readFileSync(argv.policyData));
  const fn = {
    TrustfulRiskModule: ensuro.newPolicy,
    FlightDelayRiskModule: ensuro.newFlightDelayPolicy
  }[argv.rmType];
  const tx = await fn(argv.internalId, policyData, argv.customer, rm);
  // The transaction was sent to the blockchain. It might take sometime to approve, to
  // avoid sending duplicated policies, it's better to save the {tx.hash} and check asyncronously
  // the result of the transaction
  const receipt = await tx.wait();
  const createPolicyData = ensuro.decodeNewPolicyReceipt(receipt);
  console.log(`New Policy was created with internalId: ${argv.internalId} - TX: ${tx.hash}`);
  // Copy fields from input file into output file
  if (argv.copyFields) {
    argv.copyFields.split(",").forEach((fieldName) => {
      createPolicyData[fieldName] = policyData[fieldName];
    });
  }
  const outputFile = argv.outputFile || `./PolicyData-${argv.internalId}.json`;
  fs.writeFile(outputFile, JSON.stringify(createPolicyData, null, 4), (err) => {
    if (err) {  console.error(err);  return; };
  });
}

async function resolvePolicyCommand(argv) {
  const policyData = JSON.parse(fs.readFileSync(argv.policyData));
  const rm = new ethers.Contract(policyData.riskModule, ensuro.ABIS.TrustfulRiskModule, signer);
  let tx;
  if (argv.result.toLowerCase() == "false" || argv.result.toLowerCase() == "true") {
    tx = await ensuro.resolvePolicyFullPayout(policyData.data, argv.result.toLowerCase() == "true", rm);
  } else {
    tx = await ensuro.resolvePolicy(policyData.data, Number.parseFloat(argv.result), rm);
  }
  await tx.wait();
}

async function resolveFDPolicyCommand(argv) {
  const rm = new ethers.Contract(argv.rmAddress, ensuro.ABIS.FlightDelayRiskModule, signer);
  let tx;
  let policyId = argv.rmAddress + argv.internalId.toString(16).padStart(24, "0");
  tx = await ensuro.resolveFlightDelayPolicy(policyId, rm);
  await tx.wait();
}

async function listETokens(argv) {
  const pool = new ethers.Contract(argv.poolAddress, ensuro.ABIS.PolicyPool, signer);
  const eTokens = await ensuro.getETokens(pool);
  eTokens.forEach(async etk => {
    const etkName = await etk.name();
    console.log(`Token ${etkName}`);
  });
}

yargs.scriptName("ensuro-cli")
  .usage('$0 <cmd> [args]')
  .command('new-policy <internalId> <policyData> <customer> [--rm <rm-address>]',
           'Create new policy', (yargs) => {
    yargs.positional('internalId', {
      type: 'number',
      describe: 'Policy Internal Id'
    });
    yargs.positional('policyData', {
      type: 'string',
      describe: 'Json file with the data of the policy to be created - See sample-policy.json'
    });
    yargs.positional('customer', {
      type: 'string',
      describe: 'Address that pays the premium and receives the payout'
    });
    yargs.option("rmType", {
      describe: "Type of RiskModule",
      default: "TrustfulRiskModule"
    });
    yargs.option("rmAddress", {
      describe: "Address of the RiskModule contract ",
      type: "string",
      default: RM_ADDRESS
    });
    yargs.option("outputFile", {
      type: "string",
      describe: "Output file where the policy data will be saved (json)",
    });
    yargs.option("copyFields", {
      type: "string",
      describe: "Fields to copy from input file into output file",
    });
  }, newPolicyCommand)
  .command('resolve-policy <policyData> <result>', 'Resolve policy', (yargs) => {
    yargs.positional('policyData', {
      type: 'string',
      describe: 'Json file with the full data of the policy, generated by new-policy'
    });
    yargs.positional('result', {
      type: 'string',
      describe: 'Resolution of the policy. Might be "true" or "false" if full payout or number'
    });
  }, resolvePolicyCommand)
  .command('resolve-fd-policy <internalId> [--rm <rm-address>]',
           'Triggers resolution of Flight Delay policy', (yargs) => {
    yargs.positional('internalId', {
      type: 'number',
      describe: 'Internal Id of the policy'
    });
    yargs.option("rmAddress", {
      describe: "Address of the RiskModule contract ",
      type: "string",
      default: RM_ADDRESS
    });
  }, resolveFDPolicyCommand)
  .command('list-etokens [--onlyActive] [--pool pool-address]', 'List ETokens', (yargs) => {
    yargs.option("onlyActive", {
      describe: "Show only active eTokens",
      default: false
    });
    yargs.option("poolAddress", {
      describe: "Pool Address",
      default: process.env.POOL_ADDRESS
    });
  }, listETokens)
  .help()
  .argv;
