#!/usr/bin/env node

const { ethers } = require('ethers');
const fs = require('fs');

const RM_ADDRESS = process.env.RM_ADDRESS;

const yargs = require('yargs');
const ensuro = require('./ensuro.js');
const envsigner = require('./envsigner.js');
const signer = envsigner.getSigner(process.env);

async function newPolicyCommand(argv) {
  const rm = new ethers.Contract(argv.rmAddress, ensuro.ABIS.TrustfulRiskModule, signer);
  const policyData = JSON.parse(fs.readFileSync(argv.policyData));
  const tx = await ensuro.newPolicy(policyData, argv.customer, rm);
  // The transaction was sent to the blockchain. It might take sometime to approve, to
  // avoid sending duplicated policies, it's better to save the {tx.hash} and check asyncronously
  // the result of the transaction
  const receipt = await tx.wait();
  const createPolicyData = ensuro.decodeNewPolicyReceipt(receipt);
  console.log(`New Policy was created with id: ${createPolicyData.id}`);
  const outputFile = argv.outputFile || `./PolicyData-${createPolicyData.id}.json`;
  fs.writeFile(outputFile, JSON.stringify(createPolicyData, null, 4), (err) => {
    if (err) {  console.error(err);  return; };
  });
}

async function resolvePolicyCommand(argv) {
  const policyData = JSON.parse(fs.readFileSync(argv.policyData));
  const rm = new ethers.Contract(policyData.riskModule, abi, signer);
  let tx;
  if (argv.result.toLowerCase() == "false" || argv.result.toLowerCase() == "true") {
    tx = await ensuro.resolvePolicyFullPayout(policyData.data, argv.result.toLowerCase() == "true", rm);
  } else {
    tx = await ensuro.resolvePolicy(policyData.data, Number.parseFloat(argv.result), rm);
  }
  await tx.wait();
}

async function listETokens(argv) {
  const pool = new ethers.Contract(argv.poolAddress, ensuro.ABIS.PolicyPool, signer);
  const eTokens = await ensuro.getETokens(pool);
  eTokens.forEach(async etk => {
    const etkName = await etk.name();
    console.log(`Token ${etkName}`);
  });
}

yargs.scriptName("ensuro-cli")
  .usage('$0 <cmd> [args]')
  .command('new-policy <policyData> <customer> [--rm <rm-address>]', 'Create new policy', (yargs) => {
    yargs.positional('policyData', {
      type: 'string',
      describe: 'Json file with the data of the policy to be created - See sample-policy.json'
    });
    yargs.positional('customer', {
      type: 'string',
      describe: 'Address that pays the premium and receives the payout'
    });
    yargs.option("rmAddress", {
      describe: "Address of the RiskModule contract ",
      default: RM_ADDRESS
    });
    yargs.option("outputFile", {
      describe: "Output file where the policy data will be saved (json)",
    });
  }, newPolicyCommand)
  .command('resolve-policy <policyData> <result>', 'Resolve policy', (yargs) => {
    yargs.positional('policyData', {
      type: 'string',
      describe: 'Json file with the full data of the policy, generated by new-policy'
    });
    yargs.positional('result', {
      type: 'string',
      describe: 'Resolution of the policy. Might be "true" or "false" if full payout or number'
    });
  }, resolvePolicyCommand)
  .command('list-etokens [--onlyActive] [--pool pool-address]', 'List ETokens', (yargs) => {
    yargs.option("onlyActive", {
      describe: "Show only active eTokens",
      default: false
    });
    yargs.option("poolAddress", {
      describe: "Pool Address",
      default: process.env.POOL_ADDRESS
    });
  }, listETokens)
  .help()
  .argv;
